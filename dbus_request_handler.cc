#include <cstdlib>
#include <cstring>
#include <memory>
#include <vector>

#include <gio/gio.h>

#include "app.h"
#include "config_manager.h"
#include "dbus_request_handler.h"
#include "event_receiver.h"
#include "xidlechain_action_generated.h"
#include "xidlechain_generated.h"

using std::abort;
using std::make_shared;
using std::memcpy;
using std::sscanf;
using std::vector;

template<typename T>
class VTableReplacer {
    static GDBusInterfaceVTable custom_vtable;
    static GDBusInterfaceVTable *get_custom_vtable(GDBusInterfaceSkeleton*) {
        return &custom_vtable;
    }
public:
    static GDBusInterfaceSetPropertyFunc original_set_property_func;
    static void replace_set_property_method(T *object, GDBusInterfaceSetPropertyFunc new_set_property_func) {
        GDBusInterfaceSkeleton *skeleton = G_DBUS_INTERFACE_SKELETON(object);
        GDBusInterfaceSkeletonClass *skeleton_class = G_DBUS_INTERFACE_SKELETON_GET_CLASS(skeleton);
        if (skeleton_class->get_vtable == get_custom_vtable) {
            // We already replaced the set_property method for this clas
            return;
        }
        GDBusInterfaceVTable *vtable = skeleton_class->get_vtable(skeleton);
        original_set_property_func = vtable->set_property;
        // The autogenerated vtable is const, so we have to create a new one
        memcpy(&custom_vtable, vtable, sizeof(GDBusInterfaceVTable));
        custom_vtable.set_property = new_set_property_func;
        skeleton_class->get_vtable = get_custom_vtable;
    }
};

template<>
GDBusInterfaceSetPropertyFunc VTableReplacer<CXidlechain>::original_set_property_func = nullptr;

template<>
GDBusInterfaceVTable VTableReplacer<CXidlechain>::custom_vtable = {0};

template<>
GDBusInterfaceSetPropertyFunc VTableReplacer<CXidlechainAction>::original_set_property_func = nullptr;

template<>
GDBusInterfaceVTable VTableReplacer<CXidlechainAction>::custom_vtable = {0};

namespace Xidlechain {
    DbusRequestHandler* DbusRequestHandler::INSTANCE = nullptr;

    gboolean DbusRequestHandler::static_set_property_func(
        GDBusConnection *connection,
        const gchar *sender,
        const gchar *object_path,
        const gchar *interface_name,
        const gchar *property_name,
        GVariant *value,
        GError **error,
        gpointer user_data
    ) {
        g_debug("Received request to set property %s on object %s", property_name, object_path);
        if (!INSTANCE->handle_set_property(
            object_path,
            property_name,
            value,
            error
        )) {
            return FALSE;
        }
        return VTableReplacer<CXidlechain>::original_set_property_func(
            connection,
            sender,
            object_path,
            interface_name,
            property_name,
            value,
            error,
            user_data
        );
    }

    gboolean DbusRequestHandler::handle_set_property(
        const gchar *object_path,
        const gchar *property_name,
        GVariant *value,
        GError **error
    ) {
        // If the request has invalid DBus semantics (e.g. wrong property
        // name), then we return true to let the autogenerated code handle
        // the error.
        // If the request has valid DBus semantics but it still invalid input
        // (e.g. an invalid setting value), then we set the error and return
        // false.
        // Otherwise, we return true.
        bool success = false;
        g_autoptr(GVariant) old_value = NULL;
        ConfigChangeInfo cfg_info;
        cfg_info.name = property_name;
        if (
            g_strcmp0(property_name, "IgnoreAudio") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_BOOLEAN)
        ) {
            old_value = g_variant_new_boolean(cfg->ignore_audio);
            success = cfg->set_ignore_audio(g_variant_get_boolean(value));
        } else if (
            g_strcmp0(property_name, "WaitBeforeSleep") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_BOOLEAN)
        ) {
            old_value = g_variant_new_boolean(cfg->wait_before_sleep);
            success = cfg->set_wait_before_sleep(g_variant_get_boolean(value));
        } else if (
            g_strcmp0(property_name, "DisableAutomaticDPMSActivation") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_BOOLEAN)
        ) {
            old_value = g_variant_new_boolean(cfg->disable_automatic_dpms_activation);
            success = cfg->set_disable_automatic_dpms_activation(g_variant_get_boolean(value));
        } else if (
            g_strcmp0(property_name, "DisableScreensaver") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_BOOLEAN)
        ) {
            old_value = g_variant_new_boolean(cfg->disable_screensaver);
            success = cfg->set_disable_screensaver(g_variant_get_boolean(value));
        } else if (
            g_strcmp0(property_name, "WakeResumesActivity") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_BOOLEAN)
        ) {
            old_value = g_variant_new_boolean(cfg->wake_resumes_activity);
            success = cfg->set_wake_resumes_activity(g_variant_get_boolean(value));
        } else {
            // Invalid property name or value type; let the autogenerated
            // function handle the error.
            return TRUE;
        }
        if (!success) {
            g_set_error(error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "Invalid value for property %s", property_name);
            return FALSE;
        }

        g_assert_nonnull(old_value);
        cfg_info.old_value = old_value;
        event_receiver->receive(EVENT_CONFIG_CHANGED, &cfg_info);
        return TRUE;
    }

    gboolean DbusRequestHandler::static_set_property_func_for_action(
        GDBusConnection *connection,
        const gchar *sender,
        const gchar *object_path,
        const gchar *interface_name,
        const gchar *property_name,
        GVariant *value,
        GError **error,
        gpointer user_data
    ) {
        g_debug("Received request to set property %s on object %s", property_name, object_path);
        if (!INSTANCE->handle_set_property_for_action(
            object_path,
            property_name,
            value,
            error
        )) {
            return FALSE;
        }
        return VTableReplacer<CXidlechainAction>::original_set_property_func(
            connection,
            sender,
            object_path,
            interface_name,
            property_name,
            value,
            error,
            user_data
        );
    }

    gboolean DbusRequestHandler::handle_set_property_for_action(
        const gchar *object_path,
        const gchar *property_name,
        GVariant *value,
        GError **error
    ) {
        int action_id;
        g_autofree gchar *format_str = g_strdup_printf("%s/action/%%d", DBUS_OBJECT_BASE_PATH);
        if (sscanf(object_path, format_str, &action_id) != 1) {
            g_warning("Could not parse action ID from DBus object path: %s", object_path);
            g_set_error(error, G_DBUS_ERROR, G_DBUS_ERROR_FAILED, "Internal error: could not parse action ID");
            return FALSE;
        }
        shared_ptr<Command> cmd = cfg->lookup_command(action_id);
        if (!cmd) {
            g_warning("Action ID not found: %d", action_id);
            g_set_error(error, G_DBUS_ERROR, G_DBUS_ERROR_FAILED, "Internal error: could not find action ID");
            return FALSE;
        }
        bool success = false;
        CommandChangeInfo info;
        info.cmd = cmd;
        info.name = property_name;
        g_autoptr(GVariant) old_value = NULL;
        if (
            g_strcmp0(property_name, "Name") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_STRING)
        ) {
            old_value = g_variant_new_string(cmd->name.c_str());
            success = cfg->set_command_name(*cmd, g_variant_get_string(value, NULL));
        } else if (
            g_strcmp0(property_name, "Trigger") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_STRING)
        ) {
            old_value = g_variant_new_int32(cmd->trigger);
            success = cfg->set_command_trigger(*cmd, g_variant_get_string(value, NULL));
        } else if (
            g_strcmp0(property_name, "Exec") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_STRING)
        ) {
            old_value = g_variant_new_string(cmd->activation_action->get_cmd_str());
            success = cfg->set_command_activation_action(*cmd, g_variant_get_string(value, NULL));
        } else if (
            g_strcmp0(property_name, "ResumeExec") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_STRING)
        ) {
            old_value = g_variant_new_string(cmd->deactivation_action->get_cmd_str());
            success = cfg->set_command_deactivation_action(*cmd, g_variant_get_string(value, NULL));
        } else {
            // Invalid property name or value type; let the autogenerated
            // function handle the error.
            return TRUE;
        }
        if (!success) {
            g_set_error(error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "Invalid value for property %s", property_name);
            return FALSE;
        }
        g_assert_nonnull(old_value);
        info.old_value = old_value;
        event_receiver->receive(EVENT_COMMAND_CHANGED, &info);
        return TRUE;
    }

    gboolean DbusRequestHandler::static_on_add_action(
        CXidlechain *object,
        GDBusMethodInvocation *invocation,
        const gchar *name,
        const gchar *trigger,
        const gchar *exec,
        const gchar *resume_exec,
        gpointer user_data
    ) {
        g_debug("Adding new command '%s'", name);
        DbusRequestHandler *_this = (DbusRequestHandler*)user_data;
        _this->on_add_action(object, invocation, name, trigger, exec, resume_exec);
        return TRUE;
    }

    void DbusRequestHandler::on_add_action(
        CXidlechain *object,
        GDBusMethodInvocation *invocation,
        const gchar *name,
        const gchar *trigger,
        const gchar *exec,
        const gchar *resume_exec
    ) {
        shared_ptr<Command> cmd = make_shared<Command>();
        if (!cfg->set_command_name(*cmd, name)) {
            g_dbus_method_invocation_return_dbus_error(invocation, DBUS_ERROR_NAME, "invalid name");
            return;
        }
        if (!cfg->set_command_trigger(*cmd, trigger)) {
            g_dbus_method_invocation_return_dbus_error(invocation, DBUS_ERROR_NAME, "invalid trigger");
            return;
        }
        if (!cfg->set_command_activation_action(*cmd, exec)) {
            g_dbus_method_invocation_return_dbus_error(invocation, DBUS_ERROR_NAME, "invalid activation action");
            return;
        }
        if (!cfg->set_command_deactivation_action(*cmd, resume_exec)) {
            g_dbus_method_invocation_return_dbus_error(invocation, DBUS_ERROR_NAME, "invalid deactivation action");
            return;
        }
        int id = cfg->add_command(cmd);
        event_receiver->receive(EVENT_COMMAND_ADDED, (gpointer)(long)id);

        add_action_to_object_manager(*cmd);
        c_xidlechain_complete_add_action(object, invocation, id);
    }

    gboolean DbusRequestHandler::static_on_remove_action(
        CXidlechain *object,
        GDBusMethodInvocation *invocation,
        gint id,
        gpointer user_data
    ) {
        g_debug("Removing command with ID %d", id);
        DbusRequestHandler *_this = (DbusRequestHandler*)user_data;
        _this->on_remove_action(object, invocation, id);
        return TRUE;
    }

    void DbusRequestHandler::on_remove_action(
        CXidlechain *object,
        GDBusMethodInvocation *invocation,
        gint id
    ) {
        shared_ptr<Command> cmd = cfg->lookup_command(id);
        if (!cmd) {
            g_dbus_method_invocation_return_dbus_error(invocation, DBUS_ERROR_NAME, "Internal error: could not find command");
            return;
        }
        cfg->remove_command(id);
        RemovedCommandInfo info = {id, cmd->trigger};
        event_receiver->receive(EVENT_COMMAND_REMOVED, &info);
        g_autofree gchar *path = g_strdup_printf("%s/action/%d", DBUS_OBJECT_BASE_PATH, id);
        if (!g_dbus_object_manager_server_unexport(object_manager, path)) {
            g_warning("Command %d was not removed", id);
        }
        c_xidlechain_complete_remove_action(object, invocation);
    }

    void DbusRequestHandler::on_bus_acquired(
        GDBusConnection *connection,
        const gchar *name
    ) {
        // Export the [Main] section
        CXidlechain *config_iface = c_xidlechain_skeleton_new();
        VTableReplacer<CXidlechain>::replace_set_property_method(config_iface, static_set_property_func);
        c_xidlechain_set_ignore_audio(config_iface, cfg->ignore_audio);
        c_xidlechain_set_wait_before_sleep(config_iface, cfg->wait_before_sleep);
        c_xidlechain_set_disable_automatic_dpmsactivation(config_iface, cfg->disable_automatic_dpms_activation);
        c_xidlechain_set_disable_screensaver(config_iface, cfg->disable_screensaver);
        c_xidlechain_set_wake_resumes_activity(config_iface, cfg->wake_resumes_activity);
        g_autoptr(GError) error = NULL;
        if (!g_dbus_interface_skeleton_export(
            G_DBUS_INTERFACE_SKELETON(config_iface),
            connection,
            DBUS_OBJECT_BASE_PATH,
            &error
        )) {
            g_warning(error->message);
            g_object_unref(config_iface);
            return;
        }

        // Export each of the [Action ...] sections as separate objects
        g_autofree gchar *object_manager_path = g_strdup_printf("%s/action", DBUS_OBJECT_BASE_PATH);
        object_manager = g_dbus_object_manager_server_new(object_manager_path);
        for (shared_ptr<Command> cmd : cfg->get_all_commands()) {
            add_action_to_object_manager(*cmd);
        }
        g_dbus_object_manager_server_set_connection(object_manager, connection);

        // Add handlers for the methods
        g_signal_connect(config_iface,
                         "handle-add-action",
                         G_CALLBACK(static_on_add_action),
                         this);
        g_signal_connect(config_iface,
                         "handle-remove-action",
                         G_CALLBACK(static_on_remove_action),
                         this);

        // config_iface doesn't get unref'd (LEAK)
    }

    void DbusRequestHandler::static_on_bus_acquired(
        GDBusConnection *connection,
        const gchar *name,
        gpointer user_data
    ) {
        g_debug("Acquired a bus connection");
        DbusRequestHandler *_this = (DbusRequestHandler*)user_data;
        _this->on_bus_acquired(connection, name);
    }

    void DbusRequestHandler::static_on_name_lost(
        GDBusConnection *connection,
        const gchar *name,
        gpointer user_data
    ) {
        if (connection == NULL) {
            g_critical("Connection to bus could not be made");
        } else {
            g_critical("Could not acquire name %s", name);
        }
        abort();
    }

    void DbusRequestHandler::static_on_name_acquired(
        GDBusConnection *connection,
        const gchar *name,
        gpointer user_data
    ) {
        g_debug("Acquired name %s", name);
    }

    void DbusRequestHandler::add_action_to_object_manager(Command &cmd) {
        g_assert(cmd.id != 0);
        // An object called 'Action' on the DBus interface is actually
        // called 'Command' in our code.
        // Maybe we should rename this...
        g_autofree gchar *object_path = g_strdup_printf("%s/action/%d", DBUS_OBJECT_BASE_PATH, cmd.id);
        CObjectSkeleton *object = c_object_skeleton_new(object_path);
        CXidlechainAction *action = c_xidlechain_action_skeleton_new();
        VTableReplacer<CXidlechainAction>::replace_set_property_method(action, static_set_property_func_for_action);
        c_xidlechain_action_set_name(action, cmd.name.c_str());
        g_autofree gchar *trigger = cmd.get_trigger_str();
        c_xidlechain_action_set_trigger(action, trigger);
        if (cmd.activation_action) {
            c_xidlechain_action_set_exec(action, cmd.activation_action->get_cmd_str());
        }
        if (cmd.deactivation_action) {
            c_xidlechain_action_set_resume_exec(action, cmd.deactivation_action->get_cmd_str());
        }
        c_object_skeleton_set_xidlechain_action(object, action);
        g_object_unref(action);
        g_dbus_object_manager_server_export(object_manager, G_DBUS_OBJECT_SKELETON(object));
        g_object_unref(object);
    }

    void DbusRequestHandler::init(
        ConfigManager *config_manager,
        EventReceiver *event_receiver
    ) {
        cfg = config_manager;
        this->event_receiver = event_receiver;
        INSTANCE = this;
        bus_identifier = g_bus_own_name(
            G_BUS_TYPE_SESSION,
            DBUS_BUS_NAME,
            G_BUS_NAME_OWNER_FLAGS_NONE,
            static_on_bus_acquired,
            static_on_name_acquired,
            static_on_name_lost,
            this,
            NULL
        );
    }
}
