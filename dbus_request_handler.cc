#include <cstdlib>
#include <cstring>
#include <vector>

#include <gio/gio.h>

#include "app.h"
#include "config_manager.h"
#include "dbus_request_handler.h"
#include "event_receiver.h"
#include "xidlechain_action_generated.h"
#include "xidlechain_generated.h"

using std::abort;
using std::memcpy;
using std::vector;

template<typename T>
class VTableReplacer {
    static GDBusInterfaceVTable custom_vtable;
    static GDBusInterfaceVTable *get_custom_vtable(GDBusInterfaceSkeleton*) {
        return &custom_vtable;
    }
public:
    static GDBusInterfaceSetPropertyFunc original_set_property_func;
    static void replace_set_property_method(T *object, GDBusInterfaceSetPropertyFunc new_set_property_func) {
        GDBusInterfaceSkeleton *skeleton = G_DBUS_INTERFACE_SKELETON(object);
        GDBusInterfaceSkeletonClass *skeleton_class = G_DBUS_INTERFACE_SKELETON_GET_CLASS(skeleton);
        if (skeleton_class->get_vtable == get_custom_vtable) {
            // We already replaced the set_property method for this clas
            return;
        }
        GDBusInterfaceVTable *vtable = skeleton_class->get_vtable(skeleton);
        original_set_property_func = vtable->set_property;
        // The autogenerated vtable is const, so we have to create a new one
        memcpy(&custom_vtable, vtable, sizeof(GDBusInterfaceVTable));
        custom_vtable.set_property = new_set_property_func;
        skeleton_class->get_vtable = get_custom_vtable;
    }
};

template<>
GDBusInterfaceSetPropertyFunc VTableReplacer<CXidlechain>::original_set_property_func = nullptr;

template<>
GDBusInterfaceVTable VTableReplacer<CXidlechain>::custom_vtable = {0};

template<>
GDBusInterfaceSetPropertyFunc VTableReplacer<CXidlechainAction>::original_set_property_func = nullptr;

template<>
GDBusInterfaceVTable VTableReplacer<CXidlechainAction>::custom_vtable = {0};

namespace Xidlechain {
    DbusRequestHandler* DbusRequestHandler::INSTANCE = nullptr;

    gboolean DbusRequestHandler::static_set_property_func(
        GDBusConnection *connection,
        const gchar *sender,
        const gchar *object_path,
        const gchar *interface_name,
        const gchar *property_name,
        GVariant *value,
        GError **error,
        gpointer user_data
    ) {
        g_debug("Received request to set property %s", property_name);
        if (!INSTANCE->handle_set_property(
            object_path,
            property_name,
            value,
            error
        )) {
            return FALSE;
        }
        return VTableReplacer<CXidlechain>::original_set_property_func(
            connection,
            sender,
            object_path,
            interface_name,
            property_name,
            value,
            error,
            user_data
        );
    }

    gboolean DbusRequestHandler::handle_set_property(
        const gchar *object_path,
        const gchar *property_name,
        GVariant *value,
        GError **error
    ) {
        // If the request has invalid DBus semantics (e.g. wrong property
        // name), then we return true to let the autogenerated code handle
        // the error.
        // If the request has valid DBus semantics but it still invalid input
        // (e.g. an invalid setting value), then we set the error and return
        // false.
        // Otherwise, we return true.
        bool success = false;
        g_autoptr(GVariant) old_value = NULL;
        ConfigChangeInfo cfg_info;
        cfg_info.name = property_name;
        cfg_info.new_value = value;
        if (
            g_strcmp0(property_name, "IgnoreAudio") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_BOOLEAN)
        ) {
            old_value = g_variant_new_boolean(cfg->ignore_audio);
            success = cfg->set_ignore_audio(g_variant_get_boolean(value));
        } else if (
            g_strcmp0(property_name, "WaitBeforeSleep") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_BOOLEAN)
        ) {
            old_value = g_variant_new_boolean(cfg->wait_before_sleep);
            success = cfg->set_wait_before_sleep(g_variant_get_boolean(value));
        } else if (
            g_strcmp0(property_name, "DisableAutomaticDPMSActivation") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_BOOLEAN)
        ) {
            old_value = g_variant_new_boolean(cfg->disable_automatic_dpms_activation);
            success = cfg->set_disable_automatic_dpms_activation(g_variant_get_boolean(value));
        } else if (
            g_strcmp0(property_name, "DisableScreensaver") == 0
            && g_variant_is_of_type(value, G_VARIANT_TYPE_BOOLEAN)
        ) {
            old_value = g_variant_new_boolean(cfg->disable_screensaver);
            success = cfg->set_disable_screensaver(g_variant_get_boolean(value));
        } else {
            // Invalid property name or value type; let the autogenerated
            // function handle the error.
            return true;
        }
        if (!success) {
            g_set_error(error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "Invalid value for property %s", property_name);
            return FALSE;
        }

        g_assert_nonnull(old_value);
        cfg_info.old_value = old_value;
        event_receiver->receive(EVENT_CONFIG_CHANGED, &cfg_info);
        return TRUE;
    }

    void DbusRequestHandler::on_bus_acquired(
        GDBusConnection *connection,
        const gchar *name
    ) {
        // Export the [Main] section
        CXidlechain *config_iface = c_xidlechain_skeleton_new();
        VTableReplacer<CXidlechain>::replace_set_property_method(config_iface, static_set_property_func);
        c_xidlechain_set_ignore_audio(config_iface, cfg->ignore_audio);
        c_xidlechain_set_wait_before_sleep(config_iface, cfg->wait_before_sleep);
        c_xidlechain_set_disable_automatic_dpmsactivation(config_iface, cfg->disable_automatic_dpms_activation);
        c_xidlechain_set_disable_screensaver(config_iface, cfg->disable_screensaver);
        g_autoptr(GError) error = NULL;
        if (!g_dbus_interface_skeleton_export(
            G_DBUS_INTERFACE_SKELETON(config_iface),
            connection,
            DBUS_OBJECT_BASE_PATH,
            &error
        )) {
            g_warning(error->message);
            g_object_unref(config_iface);
            return;
        }
        // config_iface doesn't get unref'd

        // Export each of the [Action ...] sections as separate objects
        g_autofree gchar *object_manager_path = g_strdup_printf("%s/action", DBUS_OBJECT_BASE_PATH);
        GDBusObjectManagerServer *manager = g_dbus_object_manager_server_new(object_manager_path);
        add_action_objects_from_list(manager, cfg->timeout_commands);
        add_action_objects_from_list(manager, cfg->sleep_commands);
        add_action_objects_from_list(manager, cfg->lock_commands);
        g_dbus_object_manager_server_set_connection(manager, connection);
        // manager doesn't get unref'd
    }

    void DbusRequestHandler::static_on_bus_acquired(
        GDBusConnection *connection,
        const gchar *name,
        gpointer user_data
    ) {
        g_debug("Acquired a bus connection");
        DbusRequestHandler *_this = (DbusRequestHandler*)user_data;
        _this->on_bus_acquired(connection, name);
    }

    void DbusRequestHandler::static_on_name_lost(
        GDBusConnection *connection,
        const gchar *name,
        gpointer user_data
    ) {
        if (connection == NULL) {
            g_critical("Connection to bus could not be made");
        } else {
            g_critical("Could not acquire name %s", name);
        }
        abort();
    }

    void DbusRequestHandler::static_on_name_acquired(
        GDBusConnection *connection,
        const gchar *name,
        gpointer user_data
    ) {
        g_debug("Acquired name %s", name);
    }

    void DbusRequestHandler::add_action_objects_from_list(GDBusObjectManagerServer *manager, vector<Command> &list) {
        static int counter = 0;
        // An object called 'Action' on the DBus interface is actually
        // called 'Command' in our code.
        // Maybe we should rename this...
        for (Command &cmd : list) {
            int id = ++counter;
            gchar *object_path = g_strdup_printf("%s/action/%d", DBUS_OBJECT_BASE_PATH, id);
            CObjectSkeleton *object = c_object_skeleton_new(object_path);
            g_free(object_path);
            CXidlechainAction *action = c_xidlechain_action_skeleton_new();
            c_xidlechain_action_set_name(action, cmd.name.c_str());
            g_autofree gchar *trigger = cmd.get_trigger_str();
            c_xidlechain_action_set_trigger(action, trigger);
            if (cmd.activation_action) {
                c_xidlechain_action_set_exec(action, cmd.activation_action->get_cmd_str());
            }
            if (cmd.deactivation_action) {
                c_xidlechain_action_set_resume_exec(action, cmd.deactivation_action->get_cmd_str());
            }
            c_object_skeleton_set_xidlechain_action(object, action);
            g_object_unref(action);
            g_dbus_object_manager_server_export(manager, G_DBUS_OBJECT_SKELETON(object));
            g_object_unref(object);
            action_id_to_command[id] = &cmd;
        }
    }

    void DbusRequestHandler::init(
        ConfigManager *config_manager,
        EventReceiver *event_receiver
    ) {
        cfg = config_manager;
        this->event_receiver = event_receiver;
        INSTANCE = this;
        bus_identifier = g_bus_own_name(
            G_BUS_TYPE_SESSION,
            DBUS_BUS_NAME,
            G_BUS_NAME_OWNER_FLAGS_NONE,
            static_on_bus_acquired,
            static_on_name_acquired,
            static_on_name_lost,
            this,
            NULL
        );
    }
}
